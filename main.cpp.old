/*
 * Copyright (c) 2016 ARM Limited. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "mbed.h"
#include "rtos.h"
#include "NanostackInterface.h"
#include "mbed-trace/mbed_trace.h"
#include "mesh_nvm.h"

#include "NTPClient.h"
#include "ip6string.h"
#include "nanostack/socket_api.h"

void trace_printer(const char* str) {
    printf("%s\n", str);
}

#ifdef EFR32_CUSTOM_BOARD
    DigitalOut enableVCOM(ENABLE_VCOM);
#endif

MeshInterface *mesh;

static Mutex SerialOutMutex;

void thread_eui64_trace()
{
#define LOWPAN 1
#define THREAD 2
#if MBED_CONF_NSAPI_DEFAULT_MESH_TYPE == THREAD && (MBED_VERSION >= MBED_ENCODE_VERSION(5,10,0))
   uint8_t eui64[8] = {0};
   static_cast<ThreadInterface*>(mesh)->device_eui64_get(eui64);
   printf("Device EUI64 address = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", eui64[0], eui64[1], eui64[2], eui64[3], eui64[4], eui64[5], eui64[6], eui64[7]);
#endif
}

void serial_out_mutex_wait()
{
    SerialOutMutex.lock();
}

void serial_out_mutex_release()
{
    SerialOutMutex.unlock();
}

#define multicast_addr_str "ff15::810a:64d1"
#define HOST_IP			"2a02:1210:741f:d700:ad75:e110:b0a2:cb3"
#define HOST_PORT		42555

UDPSocket socket;
uint8_t multi_cast_addr[16] = {0};
static const int16_t multicast_hops = 255;

// Receive data from the server
void receiveUDP() {
    // Allocate 2K of data
    char* data = (char*)malloc(2048);
    while (1) {
        // recvfrom blocks until there is data
        nsapi_size_or_error_t size = socket.recvfrom(NULL, data, 2048);
        if (size <= 0) {
            if (size == NSAPI_ERROR_WOULD_BLOCK) continue; // OK... this is a non-blocking socket and there's no data on the line

            printf("Error while receiving data from UDP socket (%d)\n", size);
            continue;
        }

        // turn into valid C string
        data[size] = '\0';

        printf("Received %d bytes from UDP socket (%s)\n", size, data);
    }
}

int main()
{

#ifdef EFR32_CUSTOM_BOARD
    enableVCOM.write(1);
#endif
    
    
    mbed_trace_init();
    mbed_trace_print_function_set(trace_printer);
    mbed_trace_mutex_wait_function_set( serial_out_mutex_wait );
    mbed_trace_mutex_release_function_set( serial_out_mutex_release );

    printf("Start mesh-minimal application\n");

#define STR(s) #s
    printf("Build: %s %s\nMesh type: %s\n", __DATE__, __TIME__, STR(MBED_CONF_NSAPI_DEFAULT_MESH_TYPE));
#ifdef MBED_MAJOR_VERSION
    printf("Mbed OS version: %d.%d.%d\n", MBED_MAJOR_VERSION, MBED_MINOR_VERSION, MBED_PATCH_VERSION);
#endif

    printf("Target: %s\n", MBED_STRINGIFY(TARGET_NAME));

    mesh = MeshInterface::get_default_instance();
    if (!mesh) {
        printf("Error! MeshInterface not found!\n");
        return -1;
    }

    thread_eui64_trace();
    mesh_nvm_initialize();
    printf("Connecting...\n");
    int error = mesh->connect();
    if (error) {
        printf("Connection failed! %d\n", error);
        return error;
    }

    SocketAddress sockAddr;
    while (NSAPI_ERROR_OK != mesh->get_ip_address(&sockAddr))
        ThisThread::sleep_for(500);

    printf("Connected. IP = %s\n", sockAddr.get_ip_address());

    /*NTPClient* ntp = new NTPClient(mesh);

    while(1){
        ThisThread::sleep_for(5s);

        time_t time = ntp->get_timestamp();

        printf("\n### -> Current time is %d\n\n", (int)time);
    }*/

    /*while(1){
        SocketAddress srv;

        srv.set_port(8080);

        char send_buffer[20];
        char recv_buffer[20];

        memset(send_buffer, 0x00, sizeof(send_buffer));

        memset(recv_buffer, 0x00, sizeof(recv_buffer));

        UDPSocket sock;
        sock.open(mesh);
        sock.set_timeout(1000);

        //sock.sendto(nist, (void*)send_buffer, sizeof(send_buffer));

        SocketAddress source;
        const int n = sock.recvfrom(&source, (void*)recv_buffer, sizeof(recv_buffer));

        printf("\n### -> Received %d bytes from %s\n", n, source.get_ip_address());
        printf("%s\n", recv_buffer);
    }*/

    /*while(1){
        int ret = 0;

        char dst_addr_str[] = "2a02:1210:741f:d700:a66a:5b1c:4426:6985";
        uint8_t dst_ip_addr[16] = {0};
        stoip6(dst_addr_str, strlen(dst_addr_str), dst_ip_addr);

        UDPSocket sock;
        sock.open(mesh);
        sock.set_timeout(3000);

        char send_buffer[] = "Hello World!";
        char recv_buffer[30] = {0};

        SocketAddress send_sockAddr(dst_ip_addr, NSAPI_IPv6, 42555);
        ret = sock.sendto(send_sockAddr, send_buffer, sizeof(send_buffer));

        if(ret < 0){
            printf("### -> Socket send error %d\n", ret);
        } 

        SocketAddress source;
        const int n = sock.recvfrom(&source, recv_buffer, sizeof(recv_buffer));

        if(n < 0){
            printf("### -> Socket receive error %d\n", n);
        } else {
            printf("### -> Socket receive successfuly %d byte(s) from IP = %s\n", n, source.get_ip_address());
            printf("%s\n", recv_buffer);
        }

        ThisThread::sleep_for(2s);

    }*/

    stoip6(multicast_addr_str, strlen(multicast_addr_str), multi_cast_addr);

    // Open a UDP socket
    nsapi_error_t rt = socket.open(mesh);
    if (rt != NSAPI_ERROR_OK) {
        printf("Could not open UDP Socket (%d)\n", rt);
        return 1;
    }

    socket.set_blocking(false);

    //socket.setsockopt(SOCKET_IPPROTO_IPV6, SOCKET_IPV6_MULTICAST_HOPS, &multicast_hops, sizeof(multicast_hops));

    ns_ipv6_mreq_t mreq;
    memcpy(mreq.ipv6mr_multiaddr, multicast_addr_str, 16);
    mreq.ipv6mr_interface = 0;

    socket.setsockopt(SOCKET_IPPROTO_IPV6, SOCKET_IPV6_JOIN_GROUP, &mreq, sizeof(mreq));

    Thread socket_thread;
    socket_thread.start(&receiveUDP);

    /*for(int i = 0; i < 20; i++){
        printf("Sending multicast msg %d\n", i);

        char buffer[] = "Multicast msg";
        SocketAddress send_sockAddr(multi_cast_addr, NSAPI_IPv6, HOST_PORT);
        socket.sendto(send_sockAddr, buffer, sizeof(buffer));

        ThisThread::sleep_for(2s);
    }*/

    while (1) {
        char buffer[] = "ADVERT";
        SocketAddress sock_addr;
        sock_addr.set_ip_address(HOST_IP);
        sock_addr.set_port(HOST_PORT);
        socket.sendto(sock_addr, buffer, strlen(buffer));

        printf("Sent %d bytes over UDP socket (%s)\n", strlen(buffer), buffer);
        ThisThread::sleep_for(2s);
    }

    //start_mesh_udp_client_example((NetworkInterface *)mesh);

}


